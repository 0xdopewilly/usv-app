Build an AI chatbot widget that appears as a floating button in the bottom-right 
corner of the screen. When clicked, it should open a chat panel (NOT full screen) 
that stays fixed in position.
Requirements:
1. Toggle button: Fixed bottom-right corner, always visible
2. Chat panel: Opens as a floating card (about 384px wide, max 600px tall)
3. Panel should appear ABOVE the toggle button when open
4. Must NOT cover entire screen or interfere with main app
5. Use inline styles for positioning to prevent CSS conflicts
6. Clean open/close animation
Implementation approach:
- Use useState for open/close state
- Render both button and panel conditionally based on state
- Use position: 'fixed' with inline styles (NOT Tailwind classes that might conflict)
- Set high z-index (9999) to ensure it stays on top
- Panel should be a Card component that slides in from bottom-right

Step-by-Step Implementation Method:
Step 1: Create the Component File
// components/AIChatWidget.tsx (or .jsx)
import { useState } from 'react';
import { MessageCircle, X } from 'lucide-react'; // or any icon library
export function AIChatWidget() {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  return (
    <>
      {/* Chat Panel - only renders when open */}
      {isOpen && (
        <div
          style={{
            position: 'fixed',
            bottom: '5rem', // Above the toggle button
            right: '1.5rem',
            zIndex: 9999,
            width: '384px',
            maxHeight: '600px'
          }}
          className="bg-white dark:bg-gray-900 rounded-lg shadow-2xl border"
        >
          {/* Header */}
          <div className="flex items-center justify-between p-4 border-b">
            <h3 className="font-semibold">AI Assistant</h3>
            <button onClick={() => setIsOpen(false)}>
              <X className="w-5 h-5" />
            </button>
          </div>
          
          {/* Messages */}
          <div className="h-96 overflow-y-auto p-4 space-y-3">
            {messages.map((msg, i) => (
              <div key={i} className={msg.role === 'user' ? 'text-right' : ''}>
                <div className={`inline-block p-3 rounded-lg ${
                  msg.role === 'user' ? 'bg-blue-500 text-white' : 'bg-gray-100'
                }`}>
                  {msg.content}
                </div>
              </div>
            ))}
          </div>
          
          {/* Input */}
          <div className="p-4 border-t">
            <input
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              placeholder="Type your message..."
              className="w-full p-2 border rounded"
            />
          </div>
        </div>
      )}
      {/* Toggle Button - always visible */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        style={{
          position: 'fixed',
          bottom: '1.5rem',
          right: '1.5rem',
          zIndex: 9999
        }}
        className="w-14 h-14 rounded-full bg-blue-500 text-white shadow-lg hover:bg-blue-600"
      >
        {isOpen ? <X className="w-6 h-6" /> : <MessageCircle className="w-6 h-6" />}
      </button>
    </>
  );
}

Step 2: Add to Your Main App
// App.tsx or Layout.tsx
import { AIChatWidget } from './components/AIChatWidget';
function App() {
  return (
    <div>
      {/* Your existing app content */}
      
      {/* Add widget at the very end, outside main content */}
      <AIChatWidget />
    </div>
  );
}

Key Differences from SimpleChatWidget:
SimpleChatWidget (Breaking)	This Approach (Works)
Uses absolute positioning	Uses fixed positioning
Might render full screen	Controlled size (384px × 600px)
CSS classes conflict	Inline styles for critical positioning
Complex dependencies	Simple React state
Takes over entire viewport	Floats above content
Why This Won't Break Your App:
Inline styles = highest specificity, won't conflict with your CSS
Conditional rendering = panel only exists in DOM when needed
Fixed positioning = doesn't affect document flow
High z-index = stays on top without breaking layout
Self-contained = no external dependencies that could cause blank screens
Quick Fix Checklist:
✅ Use position: 'fixed' in inline styles (not CSS classes)
✅ Set specific dimensions (width: '384px', maxHeight: '600px')
✅ Place component OUTSIDE your main content wrapper
✅ Use {isOpen && <Panel />} for conditional rendering
✅ Test with zIndex: 9999 to ensure visibility

This approach is what major SaaS apps (Intercom, Drift, etc.) use - it's battle-tested and won't interfere with your layout!